/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"
#include <stdbool.h>

void print_operandos(operandos op){
	printf("%d\n",op.values.values_len);
	for(int i = 0; i < op.values.values_len;i++){
		printf("%f ",op.values.values_val[i]);
	}
	printf("\n");
}

operandos * calc_vec_complejo_1(char *host, operandos op1, char c,operandos op2);

void
calculadora_1(char *host, operandos op1, char c, operandos op2)
{
	CLIENT *clnt;
	operandos  *result_1;
	

#ifndef	DEBUG
	clnt = clnt_create (host, CALCULADORA, CALCULADORA_1, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	switch (c){
	case '+':
		result_1 = suma_1(op1,op2, clnt);
		if (result_1 == (operandos *) NULL) {
			clnt_perror (clnt, "call failed in suma, no se puede realizar dicha operacion");
		}
		break;
	case '-':
		result_1 = restar_1(op1,op2, clnt);
		if (result_1 == (operandos *) NULL) {
			clnt_perror (clnt, "call failed in resta, no se puede realizar dicha operacion");
		}
		break;
	case '*':
		result_1 = multiplica_1(op1,op2, clnt);
		if (result_1 == (operandos *) NULL) {
			clnt_perror (clnt, "call failed in multiplica, no se puede realizar dicha operacion");
		}
		break;
	case '/':
		result_1 = divide_1(op1,op2, clnt);
		if (result_1 == (operandos *) NULL) {
			clnt_perror (clnt, "call failed in division, no se puede realizar dicha operacion");
		}
		break;
		//Si vemos que se quieren hacer operaciones complejas
	case 'x':
	case 'c':
		result_1 = calc_vec_complejo_1(host, op1, c,op2);
		break;
		
	default:
		break;
	}

	if(result_1->values.values_val != NULL){
		printf("El resultado es: ");
		for(int i = 0; i < result_1->values.values_len;i++){
			printf("%f ", result_1->values.values_val[i]);
		}
		printf("\n");	
	}else{
		printf("No se ha podido realizar la operacion, (operacion invalida)\n");
	}
	
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


operandos *
calc_vec_complejo_1(char *host, operandos op1, char c,operandos op2)
{
	CLIENT *clnt;
	operandos  *result_1;

#ifndef	DEBUG
	clnt = clnt_create (host, CALC_VEC_COMPLEJO, CALC_VEC_COMPLEJO_1, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	switch (c)
	{
	case 'x':
		result_1 = producto_escalar_1(op1, op2, clnt);
		if (result_1 == (operandos *) NULL) {
			clnt_perror (clnt, "call failed");
		}
		break;
	case 'c':
		result_1 = producto_vectorial_1(op1, op2, clnt);
		if (result_1 == (operandos *) NULL) {
			clnt_perror (clnt, "call failed");
		}
		break;
	
	default:
		break;
	}
	
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */

	return result_1;
}



int
main (int argc, char *argv[])
{
	char *host;
	char c_operador;
	operandos op1,op2;

	if (argc < 2) {
		printf ("usage: %s server_host opernado1 operador operando2\n", argv[0]);
		exit (1);
	}
	host = argv[1];


	//Preprocesado para almacenar los vectores
	int s1; // Calculamos el numero de elementos del primer y segundo vector a partir del
	for(int i = 2; i < argc; i++){
		if(*argv[i] == '+' || *argv[i] == '-' || *argv[i] == '*' || *argv[i] == '/' || *argv[i] == 'x' || *argv[i] == 'c'  ){
			s1 = i;
			break;
		}
	}
	
	//Reservo memoria mas que suficiente para ambos operadores
	op1.values.values_val = (double *)malloc(sizeof(double)*(s1-1));
	op2.values.values_val = (double *)malloc(sizeof(double)*(argc - s1-1));



	//Guardo los datos de entrada en ambos operandos y el operador
	bool v1 = true;
	int size_v1 = 0;
	int size_v2 = 0;
	int index = 0;
	for(int i = 2; i < argc;i++){
		//printf("Leyend : %s\n", argv[i]);
		if(*argv[i] == '+' || *argv[i] == '-' || *argv[i] == '*' || *argv[i] == '/' || *argv[i] == 'x' || *argv[i] == 'c'){
			v1 = false;
			index = 0;
			c_operador = argv[i][0];
			continue;
		}
		if(v1){
			op1.values.values_val[index] = atof(argv[i]);
			index++;
			size_v1++;
		}else{
			op2.values.values_val[index] = atof(argv[i]);
			index++;
			size_v2++;
		}
	}
	
	op1.values.values_len = size_v1;
	op2.values.values_len = size_v2;

	//Mando a calcularlos
	calculadora_1 (host,op1,c_operador,op2);

	//Libero memoria
	free(op1.values.values_val);
	free(op2.values.values_val);
	exit (0);
}
